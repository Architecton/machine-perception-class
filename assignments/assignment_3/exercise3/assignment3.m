% (warmup)
% Analytically solve the problem by using Hough transfom: In 2-D space you
% are given four points (0, 0) , (1, 1) , (1, 0) , (2, 2) . Define the equations of the lines that run
% through at least two of these points.

% (a) To better understand how the Hough algorithm works rst look at the code below
% that fills the accumulator array with a curve for a single point.

% See accumulator_array_example.m for code.

% Make a cell array of example x and y values.
example_input = {[10, 10], [30, 60], [50, 20], [80, 90]};
figure;
% Plot results for example x and y values.
for k = 1:length(example_input)
	nxt = example_input{k};
	x = nxt(1); y = nxt(2);
	A = accumulator_array_example(x, y);
	subplot(2, 2, k);
	imagesc(A); title(strcat('x = ', string(x), ', y = ', string(y))) % Display status of the accumulator
end


% (b) %
% Create an accumulator matrix A for parameter space (rho, theta). theta is defined in the interval
% from âˆ’pi/2 to pi/2 , rho is defined on the interval from âˆ’D to D, where D is the length
% of the image diagonal. Parameters bins_rho and bins_theta dene the number of
% cells (resolution) for each of the parameters rho and theta. Initialize the accumulator by
% setting all cells to 0.

% For each edge pixel in the image generate a curve in the (rho, sigma) space using the
% equation (8) for all possible values of theta and increase the values of the corresponding
% cells in A. Display the resulting accumulator matrix using the imagesc function. You
% can test the algorithm first on a synthetic image of edges, generated by the script
% below: (see instructions for script)

% Then test the algorithm on two synthetic images, oneline.png and rectangle.png .
% Obtain an edge map for each image using function findedges and run your imple-
% mentation of Hough algorithm on the edge maps.

% see hough_find_lines.m
input('Press enter to close all figures and continue to next assignment. '); close all;
% Plot some examples.
E = zeros(100); % 100 x 100 pixel image
E(10, 10) = 1;
E(20, 20) = 1; % Set threshold to 2 to obtain line that travels through both points.
I1 = rgb2gray(imread('oneline.png'));
I2 = rgb2gray(imread('rectangle.png'));

A1 = hough_find_lines_prototype(E, 300, 300);
figure;
subplot(1, 3, 1); imagesc(A1); title('synthetic')
A2 = hough_find_lines_prototype(findedges(I1, 2, 50), 300, 300);
subplot(1, 3, 2); imagesc(A2); title('oneline.png')
A3 = hough_find_lines_prototype(findedges(I2, 2, 50), 300, 300);
subplot(1, 3, 3); imagesc(A3); title('rectangle.png')

% (c) %

% Notice that the noise and the quantization cause the curves in the accumulator
% do not cross in one single cell but rather in multiple neighborhood cells. Therefore
% implement a nonmaxima_suppression_box function, that will set all the cells that
% are not local maxima (consider the neighboring 8 cells) to 0 . Display the modied
% accumulator.

% see nonmaxima_suppresion_box.m

% (d) % Try to vectorize above functions.

% See above function source files.

% Search the parameter space and extract all the parameter pairs (rho, theta) whose cor-
% responding accumulator cell value is greater than a specied threshold threshold .
% Draw the lines that correspond to the parameter pairs using the hough_draw_lines
% function that you can find in the supplementary material.

input('Press enter to close all figures and continue to next assignment. '); close all;
[r1, t1] = hough_find_lines(E, 300, 300, 1);
figure; subplot(1, 3, 1); hough_draw_lines(E, r1(1:5), t1(1:5));
[r2, t2] = hough_find_lines(findedges2(I1, 2), 300, 300, 300);
subplot(1, 3, 2); hough_draw_lines(I1, r2, t2);
[r3, t3] = hough_find_lines(findedges2(I2, 2), 1000, 500, 100);
subplot(1, 3, 3); hough_draw_lines(I2, r3(1:12), t3(1:12));

% Read the image from files bricks.jpg and pier.jpg . Change the image to grayscale,
% detect edges using the findedges , that you have implemented previously. Then
% detect lines using your algorithm. As the results will likely depend on the number
% of pixels that vote for specific cell and this depends on the size of the image and
% the resolution of the accumulator, try sorting the pairs by their corresponding cell
% values in descending order and only select the top n = 10 lines. Use function sort
% to perform sorting. Display the results and experiment with parameters of Hough
% algorithm as well as the edge detection algorithm, e.g. try changing the number of
% cells in the accumulator or Ïƒ parameter in edge detection to obtain results that are
% similar or better to the ones shown on the image below.
input('Press enter to close all figures and continue to next assignment. '); close all;

% Parse images.
I_bricks = imread('bricks.jpg');
I_pier = imread('pier.jpg');
I_bricks_g = rgb2gray(I_bricks);
I_pier_g = rgb2gray(I_pier);

% Find edges and get rho and theta parameter values.
Ie_bricks = findedges2(I_bricks_g, 2);
Ie_pier = findedges2(I_pier_g, 2);
[rb, tb] = hough_find_lines(Ie_bricks, 800, 1500, 400);
[rp, tp] = hough_find_lines(Ie_pier, 500, 200, 200);

% Get accumulator matrix values.
A1 = hough_find_lines_prototype(Ie_bricks, 800, 1500);
A2 = hough_find_lines_prototype(Ie_pier, 500, 200);

% Plot results.
figure;
subplot(2, 2, 1); imagesc(A1); colormap bone;
subplot(2, 2, 2); imagesc(A1); colormap bone;
subplot(2, 2, 3);
hough_draw_lines(I_bricks, rb(1:12), tb(1:12)); title('Bricks')
subplot(2, 2, 4);
hough_draw_lines(I_pier, rp(1:10), tp(1:10)); title('Pier');

% (g)
% A problem of the Hough transform is that we need a new dimension
% for each additional parameter in the model, which makes the execution slow for more
% complex models. We can avoid such parameters if we can reduce the parameter space,
% e.g. by introducing domain knowledge. Recall from the previous assignment that we
% can get the local gradient angle besides its magnitude. This angle is perpendicular
% to the change and can be used to limit the scope of the parameter theta for a specic
% edge point. We therefore do not have to increase the values of the cells of the entire
% range of theta (calculate multiple values of rho), but can use the local angle and only work
% with a single (rho, theta) pair for each edge point.

input('Press enter to close all figures and continue to next assignment. '); close all;
[Imag, Idir] = imgradient(I_bricks);  % Get gradient magnitudes and directions.
Idir = Idir * pi/180;	% Convert angles in degrees to radians.
Ie = nonmaxima_suppression_line_improved(Imag, Idir);  % Get thinned edges.

% Informed line search (using gradient direction information)
[r2i, t2i, A2i] = hough_find_lines_informed(Ie, Idir, 170, 140, 20);

% Get accumulator array for non-gradient-informed Hough transform.
A2 = hough_find_lines_prototype(Ie, 300, 30);
% Plot results for comparison.
subplot(2, 2, 1); imagesc(A1)
subplot(2, 2, 2); imagesc(A2i)
subplot(2, 2, 3);
hough_draw_lines(I_bricks, rb(1:12), tb(1:12)); title('Normal')
subplot(2, 2, 4);
hough_draw_lines(I_bricks, r2i(1:12), t2i(1:12)); title('Orientation')


% (h)
% Implement a Hough transform that detects circles of a xed radius.
% You can test the algorithm on image eclipse.jpg . Try using radius somewhere
% between 45 and 50 pixels. You can use function hough_draw_circles to visualize
% the result.


% (i)
% Not all lines can accumulate the same number of votes, e.g. if the
% image is not rectangular candidates along the longer dimension are in better position.
% Extend your algorithm so that it normalizes the number of votes according to the
% maximum number of votes possible for a given line (how many pixels does a line
% cover along its crossing of the image). Demonstrate the dierence on some non-
% rectangular images where the dierence can be demonstrated clearly.